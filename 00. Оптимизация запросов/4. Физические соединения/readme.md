### Nested loops
Описание: 
  - Допустим два набора данных.
  - Берем первую строку из первого набора данных. Проходимся по всему второму набору данных. 
  - Если строки совпали, выводим.
  - Сложнось алгоритма: O(N2).

Когда применяется:
  - Если наборы данных содержат мало строк. 
  - Либо наборы содержат много строк, но режим оптимизатора FIRST_ROWS

Пример:
  1. Читаем первый блок таблицы emp.
  2. Берем первую строку из блока и используем ее значение deptno для поиска в таблице dept
  3. Читаем индексные блоки таблицы dept. Находим нужный лист с rowid строки в dept
  4. Читаем блок и строку по rowid в таблице dept.
  5. Таким образом, за четыре операций логического ввода/вывода можно получить данные.


### Merge join.
Описание: 
  - Сначала сортируем оба набора данных. Затем соединяем эти наборы.
  - Сложность алгоритма: O(N*log(N))

Когда применяется:
  - Когда нужно соеденить большой набор данных и отсортировать его.

Пример работы:
````
select a.ename,
       b.ename,
       a.hiredate,
       b.hiredate
  from emp a,
       emp b
 where a.empno = b.empno
 order by a.empno;
````

  1. Читается "EMP a" и сортируется по empno. 
  2. Читается "EMP b" и сортируется по empno. 
  3. Далее применяется соединение.

````   
1  1
3  1
4  2
6  2
   3
   5
````	 
  
  4. Сначала сравнивает первые строки двух наборов данных.
  5. Если значения равны, берем следующую строку из второго набора. 
  6. Если значения не равны, то определяем в каком наборе меньшее значение и в этом наборе переходим на следующую строку.



### Hash join
Описание:
  - Является способом объединения двух больших наборов данных или большого набора данных с маленьким. 
  - Сложность алгоритма: O(N)
  - Требует в условии =


Пример работы:
````
  select t1.object_name,
	 t2.object_name
    from t t1,
	 t t2
   where t1.object_id = t2.object_id
     and t1.owner = 'WMSYS';
````
  - Oracle выберет самый маленький набор данных, возьмет оттуда значения ключей и создаст их них хеши в разделе PGA. 
  - Этот хеш будет использоваться как индекс. 
  - Так как может быть хеш колизия (когда у 2-х разных значений 1 хеш), то к хешированным ключам добавляем само значения ключа. 
  - Если таблица помещается в оперативную память, то Oracle поместит ее в оперативную память.
  - Затем читаем второй набор данных
  - Для каждой строки второго набора Oracle хеширует ключ и находит в хеш-таблице соответствующие строки по индексу
  - Если соответствующие строки нашлись, то выводим их


Если хеш-таблица не умещается в памяти, то Oracle будет использовать пространство TEMP.
  - При переполнении области хеширования в PGA, Oracle сбрасывает часть хеш таблицы на диск в TEMP
  - Часть хеш-таблицы находится в памяти, а часть на диске.
  - Затем Oracle начинает читать второй набор данных
  - Все так же будет хешироваться ключ-значение из второго набора
  - Если хэшированное значение указывает на строку памяти строка возвращается.
  - Если хэшированное значение указывает на диске, Oracle сохранит эту строку так же на диск в TEMP.
  - В конце Oracle проведет поочередную обработку каждого временного раздела на диске, считает их в память и соеденит.
  - Затем выдаст окончательный ответ.