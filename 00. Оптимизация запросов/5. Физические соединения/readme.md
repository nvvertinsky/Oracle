### Nested loops
Описание: 
  - Допустим два набора данных.
  - Берем первую строку из первого набора данных. Проходимся по всему второму набору данных. 
  - Если строки совпали, выводим.
  - Сложнось алгоритма: O(N2).

Когда применяется:
  - Если наборы данных содержат мало строк. 
  - Либо наборы содержат много строк, но режим оптимизатора FIRST_ROWS

Как работает:
````
  select empno,
         dname
    from emp,
         dept
   where emp.deptno = dept.deptno;
````

Псевдокод логики процесса соединения:
````
  for x in (select * from emp)
  loop
    index lookup the rowid for x.deptno;
    select * from dept where dept.rowid = that rowid;
    output joined record
  end loop;
````

  1. Читаем первый блок таблицы emp.
  2. Берем первую строку из блока и используем ее значение deptno для поиска в таблице dept
  3. Читаем индексные блоки таблицы dept. Находим нужный лист с rowid строки в dept
  4. Читаем блок и строку по rowid в таблице dept.
  5. Таким образом, за четыре операций логического ввода/вывода можно получить данные.


### Merge join. Соединение сортировкой-слиянием
Описание: 
  - Соединение сортировкой-слиянием будет проводить сортировку обоих наборов данных. Затем соединяем эти наборы.
  - Соединение сортировкой-слиянием является менее эффективным, чем соединение хешированием из-за того, что ОБА набора данных необходимо подвергнуть сканированию и сортировке. При соединении хешированием предварительной обработке подтвергается только один набор
  - Сложность алгоритма: O(N*log(N))

Когда применяется:
  - Когда нужно соеденить большой набор данных и отсортировать его.
  - В условии есть <,>,>=,<=

Пример работы:
````
select a.ename,
       b.ename,
       a.hiredate,
       b.hiredate
  from emp a,
       emp b
 where a.empno = b.empno
   and a.hiredate <= b.hiredate;
````
  1. Читается "EMP a" и сортируется по empno. 
  2. Читается "EMP b" и сортируется по empno. 
  3. Далее применяется соединение сортировкой-слиянием с использованием условия a.hiredate <= b.hiredate

````   
1  1
3  1
4  2
6  2
   3
   5
````	 
  
  4. Сначала сравнивает первые строки двух наборов данных.
  5. Если значения равны, берем следующую строку из второго набора. 
  6. Если значения не равны, то определяем в каком наборе меньшее значение и в этом наборе переходим на следующую строку.



### Hash join
Описание:
  - Является способом объединения двух больших наборов данных или большого набора данных с маленьким. 
  - Сложность алгоритма: O(N)
  - Требует в условии =

Особенности:
  - Хеш функция может возвращать одно и тоже значение для разных ключей. Это хеш колизия. В этом случае Oracle помещает эти ключи в один и тот же слот 

Пример работы:
````
  select t1.object_name,
	 t2.object_name
    from t t1,
	 t t2
   where t1.object_id = t2.object_id
     and t1.owner = 'WMSYS';
````
  - Oracle выберет самый маленький набор данных, возьмет оттуда значения ключей и создаст их них хеши в разделе PGA. 
  - Этот хеш будет использоваться как индекс. 
  - Так как может быть хеш колизия (когда у 2-х разных значений 1 хеш), то к хешированным ключам добавляем само значения ключа. 
  - Если таблица помещается в оперативную память, то Oracle поместит ее в оперативную память.
  - Затем читаем второй набор данных
  - Для каждой строки второго набора Oracle хеширует ключ и находит в хеш-таблице соответствующие строки по индексу
  - Если соответствующие строки нашлись, то выводим их


Если хеш-таблица не умещается в памяти, то Oracle будет использовать пространство TEMP.
  - При переполнении области хеширования в PGA, Oracle сбрасывает часть хеш таблицы на диск в TEMP
  - Часть хеш-таблицы находится в памяти, а часть на диске.
  - Затем Oracle начинает читать второй набор данных
  - Все так же будет хешироваться ключ-значение из второго набора
  - Если хэшированное значение указывает на строку памяти строка возвращается.
  - Если хэшированное значение указывает на диске, Oracle сохранит эту строку так же на диск в TEMP.
  - В конце Oracle проведет поочередную обработку каждого временного раздела на диске, считает их в память и соеденит.
  - Затем выдаст окончательный ответ.
  
  
### Hash join (outer). Внешнее соединение хешированием.
Пример работы:
````
  select ename,
		 dname
    from emp,
		 dept
   where emp.deptno(+) = dept.deptno;
````

  1. Таблица dept сканируется и хешируется.
  2. Таблица emp сканируется для каждой строки.
  3. Хеш-таблица dept исследуется на предмет соответствий. 
    - Если соответствие находится, строка помещается в выходные данные.
	- Запись в хеш-таблице помечается как соответствующая строке.
  4. После того как закончится сканирование emp таблицы, хеш-таблица dept обрабатывается сначала, и любые не помеченные как соответствующие строки выводятся со значением null в столбцах emp.
  
### Внешнее соединения вложенным циклом. nested loops (outer)
Пример работы:
````
  select empno,
         dname
    from emp,
         dept
   where emp.deptno(+) = dept.deptno;
````

В отличии от примера с nested loops, ведущей таблицей стала dept

Псевдокод:
````
  for x in (select * from dept)
  loop
    found_record = false;
	
	for y in (select * from emp where emp.deptno = x.deptno)
	loop
	  found_record = true;
	  output joined record;
	end loop;
    
	if not found_record then
	  output a record with null values for emp columns;
	end if;
  end loop;
````

  1. Читаем первый блок таблицы dept.
  2. Берем первую строку из блока и используем ее значение deptno для поиска в таблице emp
  3. Читаем индексные блоки таблицы emp. Находим нужный лист с rowid строки в dept. Если ничего не нашли, то выводим строки из emp с null значениями
  4. Читаем блок и строку по rowid в таблице dept.
