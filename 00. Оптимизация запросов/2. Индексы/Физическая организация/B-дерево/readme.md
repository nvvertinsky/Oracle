# B-Дерево.

### Описание: 
Сбалансированное дерево. Сбалансированное потому что, между листовым блоком и корнем всегда одинаковый уровень. 

### Структура: 
  - Корневой блок - Блок с которого начинаем поиск. 
  - Листовые блоки - Самый нижний уровень. Содержат значение которое ищем и ROWID.
  - Блоки между корневым и листовым блоками
  
### Как работает: 
  1. Нам нужно найти значение 11.
  2. Поиск начинается с корневого блока.
  3. 11 входит в 0..40, значит переходим в самый левый блок.
  4. 11 входит в 11..19, значит переходит в правый листовой узел.
  5. Находим значение 11 и берем ROWID. Чтобы в дальше найти строку в таблице.

### Когда использовать:
  - Если нужно получить небольшое количество строк
  
### В каком порядке указывать столбцы в индексе: 
  - Лидирующим столбцом ставить тот, у которого больше всего уникальных значений

### Разновидность индексов: 
  - Обычные
  - Уникальные
  - Функциональные
  - С обратной сортировкой
    - Хранит значения в порядке убывания. Проще говоря в листовых блоках слева будет самое большое значение, а справа самое маленькое..
    - Когда нужны значения в порядке убывания. Пример не могу придумать. 
    - Команда create index dt_desc on rub_usd(dt desc);
  - Реверсивные
    - Описание: Это индекс, который хранит значения столбцов таблицы в обратном порядке
    - Зачем нужен: Чтобы уменьшить конкуренцию за крайний правый листовой блок индеса. Он же горячий блок.
    - Используется для монотонно возрастающих значений. Например PK.
    - Команда: create index t1_idx on t1 (id) reverse;
    - Есть ограничения, которые не позволяют использовать этот индекс постоянно (как обычный индекс): 
      - Индекс не будет использоваться при операциях поиска по диапазону col > 5
      - А так же при использовании функций min, max


### Полезные запросы:

Узнаем сколько уровней между корневыми и листовыми блоками.
````
select index_name, 
       blevel 
  from all_indexes 
 where table_name = 'US_TR';
````