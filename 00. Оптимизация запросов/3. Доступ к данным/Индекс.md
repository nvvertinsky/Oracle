### Index Full Scan
Особенности: 
  - Читаются все листовые блоки индекса слева направо
  - За одну операцию ввода вывода читаем один блок

Условия:
  1. В запросе указан order by
  2. Есть ограничение not null на столбец.
  3. Порядок использования колонок в order by должен совпадать с порядком колонок в индексе

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к самому первому листовому блоку. 
  2. После прочтения первого листового блока все остальные блоки читаются по порядку.


Пример:
````
select empno from emp order by empno;
````


### Index Fast Full Scan

Условия: Сортировка не нужна.

Как работает:
  1. Читаем каждый блок в индексе. Включая все отвлетвляющиеся. В режиме мультиблочного чтения.
  2. То есть за одну операцию I/O мы читаем несколько блоков. 
  3. Из-за этого данные не отсортированы.


Пример: 
````
select empno from emp;
````

### Index Range scan
Особенности: 
  - Применяется при поиске по диапазону >, <, between
  - Так же при равенстве id = id (если только индекс не уникальный)
  - Данные извлекаются в отсортированном порядке

Условия:
  1. В условиях запроса используются лидирующий столбец. 
  2. Не обязательно указывать все столбцы, но желательно. Тут надо экспериментировать. 

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к блоку, где находится стартовое значение диапазона. 
  2. Затем ищем нужные значения в листе
  3. Если надо, переходим с листа на лист, не поднимаясь к узлу. Возможны любые направления прохода по листам asc/desc


### Index skip scan
Особенности: Может возникнуть при использовании составных индексов, когда не задан лидирующий столбец.

Условия:
  1. Есть составной индекс (col1, col2)
  2. В условии where мы указываем только col2.
  3. Если лидирующий столбец имеет большое количество уникальных значений, скорее всего, index skip scan выбран не будет.
  4. Или же лидирующий столбец содержит мало различных значений. А второй столбец содержит много различных значений

Как работает:
  1. Для лидирующего столбца сначала ищем все уникальные значения distinct col1
  2. Дальше для каждого уникального значения выполняется range scan с учетом значения заданных столбцов.
     сol1 = 1 and col2 = 99
     col1 = 2 and col2 = 99
     col3 = 3 and col2 = 99 

Пример:
````
create index emp_name_ix on employees (last_name, first_name);
select * from employees t where t.first_name = 'Mark';
````

В предикатах не задан лидирующий столбец (“last_name”) индекса.

Уникальных значений 102. select count(distinct t.last_name) from employees t;

Будет построено 102 условных поисковых дерева и по каждому будет совершен поиск:
````
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
````


### Index Unique Scan
Самый быстрый вид индексного доступа.

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к листовоему блоку, где находится уникальное значение. 
  2. Получаем из листа rowid
  3. Обращаемся к таблице и ищем по rowid строку. 


Пример. На поле employee_id навешен PK. Соответственно, за кадром, создан уникальный индекс. Который используется в этом запросе. Поскольку у нас равенство строгое, значит искомый элемент один. Вот и получается Index Unique Scan.: 
````
select * from employees t where t.employee_id = 100;
````



### Соединения индексов
Описание: Если все нужные данные есть в нескольких индексах, то можно просканировать только эти несколько индексов, не обращаясь к самой таблице.

Условия:
  1. В запросе участвуют только поля, которые есть в индексах.

Пример выполнения:
````
select a, b, c
  from t
 where a = :a
   and b = :b;
````

  - Предположим, что есть индекс для Т(А) и индекс для Т(В,С).
  - Оптимизатор может провести сканирование индекса Т(А), затем индекса Т(В,С). 
  - После чего взять промежуточные результаты и соединить их вместе по ROWID.

