### Список:
  - Index Unique Scan
  - Index skip scan
  - Index Range scan
  - Index Full Scan
  - Index Fast Full Scan

### Index Full Scan
Особенности: 
  - Читаются все листовые блоки индекса.
  - Данные извлекаются в отсортированном виде
  - За одну операцию ввода вывода читаем один блок

Условия:
  1. В запросе указано достаточно лидирующих проиндексиронных столбцов
  2. В запросе указан order by
  3. Порядок использования колонок в order by должен совпадать с порядком колонок в индексе

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к самому первому листовому блоку. 
  2. После прочтения первого листового блока все остальные блоки читаются по порядку.


Пример 1:
````
select empno, ename from emp order by empno;
````

Пример 2. Oracle может выполнять полное сканирование индекса вместо таблицы, только если у вас есть ограничение not null на столбец. И только если данные нужны сразу отсортированные:
````
select indexed_col from table;
````

### Index Fast Full Scan
Особенности: Значительно отличается от полного сканирования индекса.

Условия: В запросе указаны лидирующие столбцы и сортировка не нужна.

Как работает:
  1. Читаем каждый блок в индексе. Включая все отвлетвляющиеся. В режиме мультиблочного чтения. Как будто полное сканирование таблицы.
  2. То есть за одну операцию I/O мы читаем несколько блоков. 
  3. Из-за этого данные не отсортированы.


Пример: 
````
select first_name, last_name from emp;
````

### Index Range scan
Особенности: 
  - Применяется при поиске по диапазону значений 
  - Применяется при равенстве id = id (если только индекс не уникальный)
  - Данные извлекаются в сортированном порядке

Условия:
  1. В условиях запроса используются лидирующий столбец. 
  2. Не обязательно указывать все столбцы, но желательно. Тут надо экспериментировать. 

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к блоку, где находится стартовое значение диапазона. 
  2. Затем происходит сканирование всех значений после этого стартового значения, в соответствии с условием. 
  3. Если надо, алгоритм переходит с листа на лист, не поднимаясь к узлу. Возможны любые направления прохода по индексу asc/desc
  
Пример 1. Будет range scan. Потому что индекс emp_department_ix не уникальный. И в листах у него не уникальные значения, а значит, добравшись до искомого листа, придется проходить по диапазону равному = 10. Таких элементов будет больше чем “1”. Потому и применяется range scan.
````
create index emp_department_ix on employees (department_id);
select * from employees t where t.department_id = 10;
````

Пример 2. В плане фигурирует range scan по unique index - emp_emp_id_pk. Казалось бы, индекс уникальный, почему не unique scan? Потому, что в where задан диапазон - меньше либо равно. При этом не важно, уникальный индекс или нет. При сканировании придется проходить листы/значения меньше числа 130 включительно.
````
select * from employees t where t.employee_id <= 130;
````

Пример 3. Oracle начинает чтение с конца индекса и считывает последнее (наивысшее) значение
````
select max(empno) from emp;
````


### Index skip scan
Особенности: Может возникнуть при использовании составных индексов, когда не задан лидирующий столбец.

Условия:
  1. Есть составной индекс (col1, col2)
  2. В условии where мы указываем только col2. Не указывая ведущий столбец col1.
  3. Если лидирующий столбец имеет большое количество уникальных значений, скорее всего, index skip scan выбран не будет.
  4. Или же лидирующий столбец содержит мало различных значений. А второй столбец содержит много различных значений

Как работает:
  1. Для лидирующего столбца сначала ищем все уникальные значения distinct col1
  2. Дальше для каждого уникального значения выполняется range scan с учетом значения заданных столбцов.
     сol1 = 1 and col2 = 99
     col1 = 2 and col2 = 99
     col3 = 3 and col2 = 99 

Пример:
````
create index emp_name_ix on employees (last_name, first_name);
select * from employees t where t.first_name = 'Mark';
````

В предикатах не задан лидирующий столбец (“last_name”) индекса.

Уникальных значений 102. select count(distinct t.last_name) from employees t;

Будет построено 102 условных поисковых дерева и по каждому будет совершен поиск:
````
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
where (last_name = ‘i-ое last_name’ and first_name = ‘Mark’).
````


### Index Unique Scan
Самый быстрый вид индексного доступа.

Как работает:
  1. Сканирование начинается с корневого блока и перемещается по ветвям вниз к листовоему блоку, где находится уникальное значение. 
  2. Получаем из листа rowid
  3. Обращаемся к таблице и ищем по rowid строку. 


Пример. На поле employee_id навешен PK. Соответственно, за кадром, создан уникальный индекс. Который используется в этом запросе. Поскольку у нас равенство строгое, значит искомый элемент один. Вот и получается Index Unique Scan.: 
````
select * from employees t where t.employee_id = 100;
````



### Соединения индексов
Описание: Если все нужные данные есть в нескольких индексах, то можно просканировать только эти несколько индексов, не обращаясь к самой таблице.

Условия:
  1. В запросе участвуют только поля, которые есть в индексах.

Пример выполнения:
````
select a, b, c
  from t
 where a = :a
   and b = :b;
````

  - Предположим, что есть индекс для Т(А) и индекс для Т(В,С).
  - Оптимизатор может провести сканирование индекса Т(А), затем индекса Т(В,С). 
  - После чего взять промежуточные результаты и соединить их вместе по ROWID.

