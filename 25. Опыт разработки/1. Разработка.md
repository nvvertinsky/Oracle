# Разработка

### Модули:

Состав подсистемы:
  - Пакет UI. Для интерфейса.
  - Пакет WI. Предоставляем внешнему сервису определенные методы.
  - Пакет API. Пакет содержит процедуры и функции для соответсвующей подсистемы при вызове извне, т.е. является аналогом спецификации для некоторой подсистемы
  - Пакет LIB. Библиотека процедур и функций для внутреннего использования внутри некоторой подсистем,, т.е. является аналогом body. Пакет, имеющий суффикс LIB, может вызываться только из объектов, входящих в эту подсистему
  - Пакет TAPI. Валидация.
  - Объекты - модели.

### Опыт: 
  - Делаем описание каждого объекта
  - Проверять входящие параметры
  - В функцию передавать параметры скалярные/объекты, чтобы использовать функцию в SQL
  - При создании новой схемы или таблицы - сделать джоб сбора статистики
  - Если нет возможности формировать xls файл в приложении, то можно формировать csv
  - Не использовать большие запросы прямо в коде самих процедур. Разбивать на более мелкие модули.
  - Если какая то функция возвращает null, то обрабатывай это
  - TAPI:
    - Делать валидацию на сервере. Если будет время, тогда еще на клиенте
	  - В TAPI делаем валидацию именно строки. Если есть поля JSON, то этот JSON не нужно валидировать. DML операции могут выполнять из разных мест.
	  - По сути ТАПИ это набор юнит тестов, которые проверяют правильность поступающих данных
  - Оставляем возможность править саму таблицу без всяких проверок.
	- Подготавливам данные в пакетах API, но в TAPI уже производит саму валидацию этих данных
  - Печатные формы вызывать через docform. Ограничения по печати писать там.
  - Любые манипуляции с данными делаем через процедуры/функции обертки в пакетах.
    - Если допустим добавится обязательный столбец, то достаточно будет добавить его в этой процедуре/функции.
  - При сохранении в базу даты, всегда пишем маску 'dd.mm.yyyy hh24:mi:ss'. Даже если сама дата без минут или секунд.
  - Дата не должна быть больше маски.
  - Параллельная разработка возможна только если будем править разные объекты
  - При разработке большого проекта невозможно написать хороший код с первого раз. Требования постоянно меняются, код меняется. Когда основная разработка будет закончена, а требования сформированы, то можно сделать рефакторинг.
  - Не обязательно знать досконально технологию. Достаточно знать что есть такая технология, которая решает определённую проблему. А за деталями обращаться к справочникам.
  - Языки программирования, low-code платформы это всего лишь инструменты. Которые нужно применять в определенных ситуациях
  - По сути код нужно писать так, чтобы это потом легко было читать/менять. То есть занимало как можно меньше времени на чтение/изменение.
  - Иногда вместо концентрации на коде, мы концентрируемся на оптимизации. Преждевременная оптимизация это зло.
  - В интерфейсе не скрываем кнопки от пользователя. Лучше при нажатии выдавать ошибку.
  - resmon.exe утилита для просмотра занятых портов.
  - Код должен быть покрыт юнит-тестами
  - Цикл разработки: 
    - Делаем сначала хреново
	  - Затем тестируем и исправляем ошибки. Делаем чтобы работало
	  - Делаем рефакторинг. Делаем более маштабируемый и изменяемый код
  - Не использовать представления. Использовать функции возвращающие объект.
    - Сложно дебажить
    - Нет обработки исключений
  - Мы должны отвечать на HTTP запросы быстро. Если нужно вызвать процедуру, которая долго выполняется, то лучше добавить сообщение в очередь.
  - Императивный код читается проще, чем большие SQL запросы.
  - При создании новой таблицы или схемы делать джоб собирающий статистику
  - Нет смысла делать константы под различные ID. Т.к. эти ID скорее всего являются FK и их не удалить и не обновить.
  - Вместо констант лучше делать функции. Так хотя бы у пакета не будет состояния и функцию можно использовать в SQL вне объектов Оракла. 
  - Всегда делать кнопку выключения всей интеграции с сохранением того что было выключено, чтобы потом можно было быстро включить. 
  - Сначала идут принципы программирования, потом шаблоны, потом конкретные алгоритмы. 
  - При оценке подумать над различными нюансами. 
  - Придумывать более абстрактные названия процедур и функций, чтобы можно было потом менять реализацию не трогая другие объекты. Например штриховой код. Это может быть как qr-код, так и штрих-код EAN13
  - Параметры проверять только в API и при возвращении HTTP ответа. Предполагаем что внутри подсистемы все вызовы правильные. 
  - DML делать через процедуры. Например при update, программист может забыть важное условие where

### Алгоритмы

Зачем нужны:
  - Проверяют не то как ты решаешь алгоритмы. Проверяют твои навыки решения неизвестных проблем.
  - Развитие интуиции при решении базовых задач
  - Навыки поиска решения проблем в условиях неопределенности
  - Умение не сдаваться сразу

Как проходить собес:
  - Попросить примеры
  - Уточнять ограничения
  - Спрашивать что не понятно
  - Набросить псевдокод
  - Сделать хреновое решение brutforce
  - Попросить подсказку